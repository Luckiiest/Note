知识回顾
	1.生产消费者模型
		可能会产生多线程并发带来的安全隐患----抢夺资源
	2.如何解决线程安全的问题
		synchronized  特征修饰符  同步的
		线程锁    锁定的是对象
		1.放置在方法的结构上
		public synchronized void test(){
			好多代码
			执行代码
			好多代码
		}
		对象.test();   对象被某一个访问他的线程锁定
		2.放置在方法(构造 块)的内部(看起来是包含着一堆代码)
		public void test(){
			好多代码
			synchronized(对象){
				执行代码
			}
			好多代码
		}
	3.线程相关的一些方法
		sleep();   run();    start();    setPriority();----------->Thread
		wait()    notify()   notifyAll()----------->Object
		注意wait方法  notify方法  使用
		对象.wait();
		对象调用wait方法  不是对象等待
		访问此对象的线程进入等待状态
	4.笔试中经常考察的关于线程的问题
		程序 进程 线程概念
		如何实现线程
		线程的几种状态
		如何切换几种状态
		wait  sleep方法区别。。。
==================================================================
	比较重要的方法    join---->Thread类
		设计一个模型
		1.有两个线程 One  Two   two加入到one里面
		2.设计模型时候  two线程在one的run里面创建    保证两个有先后顺序
		3.two.join();   无参数==0   有参数==2000
			
		one 启动
		two 启动
		three 启动
		two就join啦
		2000之后  one想要将two从自己的线程内剔除
		two对象不在自己的手里  对象被three线程锁定啦  10000
		one只能等待 threee将two对象释放后 才能踢掉

	synchronized锁 非常的厉害
	一旦对象被锁定  不释放的情况下  其他的对象都需要等待
	有可能会产生一个死锁的效果

	死锁的效果
	   模拟一个模型  演示死锁
	   如何解决死锁效果
	   经典的哲学家就餐问题
	   解决死锁的问题
		1.礼让---->产生时间差
		2.不要产生对象公用的问题

	计时器/定时器----->线程应用
	java.util包
	Timer类
	无参数构造方法 创建对象
	timer.schedule();
	
	反射机制
	注解(解析 自定义)




