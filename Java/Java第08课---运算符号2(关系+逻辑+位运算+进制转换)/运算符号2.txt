知识回顾
Java运算符
	操作数的数目分类
	    单目  双目  三目
	按照运算符的功能
	    算术运算  + - *  /  %取余 取模
		   ++  --
		    int x = 1;
		    int y = x++;
		    y==1   x==2

		   int a = 1;
		   a=a++;
		   a===>1
	    赋值运算
		=  +=  -=  *=  /=  %=
		int x = 1;
		x+=2;
		x===>3
=======================================================
	    关系运算(比较)
		>    >=    <    <=    !=    ==  (对象 instanceof 类)
		1.区分=  和 == 区别
		   =赋值符号      将=后面的结果(值 引用)存入=左边的变量空间内
		   ==比较符号   比较==前面和==后面的元素(值 引用)是否一致
		2.比较运算符的最终结果是什么?
		   boolean   true  false
		   (3>2)-->true;    (3>4)-->false;    (3==4)-->false
		   (3>=2)-->true  (3>=4)-->false;  (3!=4)-->true
		  一个条件的判定
	    逻辑运算
		逻辑运算符前后连接的两个都是boolean的值
		逻辑运算最终的结果还是boolean
		1.条件 我有时间  同时  2.条件 嗓子没有问题
		&逻辑与   | 逻辑或  ^逻辑异或   !逻辑非
		&&短路与  ||短路或
		(3>2) & (3>1)    和 并且
		 true        true
		        true
		-------------------------
		(3>4)  |  (3>5)    或者
		false    |   false
		        false
		-------------------------
		(3>1)  ^  (3>2)   异(不同的)--->前后两个结果不一致  就可以
		true         true
		       false       
		-------------------------
		!(3>2)  !true   false   非--取反 将原来的结果取反
		-------------------------
		(3>1) && (3>2) =?   
		true  &&  true	与两个条件同时满足  如果当第一个条件已经为false  最终肯定是false
		        true
		-------------------------
		(3>2) || (3>4) = ?
		true    ||                    或两个条件有一个满足  如果当第一个条件为true  最终肯定为true
		       true
		&&短路与
		1.短路 什么情况下才会发生短路?  当前面的值结果为false的时候会发生短路
		2.短路 到底短路的是什么?    短路的是&&之后所有计算的过程
		3.如果发生了短路情况  性能比&稍微好一点
		4.&逻辑与 和 &&短路与  从执行的最终结果来看没有任何区别
		5.短路与不一定提高了性能  只有当前面为false的时候才会发生短路  才会提高性能
		
		逻辑运算符前后连接的应该是两个boolean结果
		&逻辑与   可以理解为中文的"和","并且"意思  &前后两个条件必须同时满足 最终才为true
		|  逻辑或   可以理解为中文的"或者"  | 前后两个条件只要有一个满足 最终就为true
		^逻辑异或   前后两个表达式只要结果不相同 最终结果就为true(专治强迫生)
		！逻辑非   可以立即为中文的"不"   将原来的结果取反  
---------------------------------------------------------------------------------	
		知识补充
		进制转化问题?
		十进制0123456789
		二进制01
		如何将十进制--->二进制
		60十进制--->32个0或1来表示60    60除以2取余数 将余数倒叙排列 即为有效位
		00000000 00000000 00000000 00111100
		如何将二进制--->十进制   从右至左开始计算  每一个元素乘以2的位置(0开始)次幂 最终求和
		------------------------------------------
		每三个bit记录为一个小组-->小组长名字(3个bit计算成十进制)
		00000000 000  000  000  000  000  000  111  100
					             0	   7      4
		八进制01234567
		将三个二进制合并为一个  计算成十进制表示   八进制表示形式以0开头
		074
		-----------------------------------------
		每四个bit记录为一个小组-->小组长名字(4个bit计算成十进制)
		00000000 0000  0000  0000  0000  0011  1100
                                                                                       0X     3       C          10-A  11-B 12-C 13-D 14-E 15-F
		十六进制0123456789ABCDEF
		0X3C
------------------------------------------------------------------------------------------
		位(bit)运算
		&按位与  | 按位或  ^按位异或  ~按位取反
		<<按位左位移   >>按位右位移   >>>按位右位移(无符号)
			
		3 ^ 5 = ?
		1.将3和5转化成二进制表示形式
		2.竖着按照对应位置进行 & | ^计算 (1-->true 0-->false)
		3.将计算后的二进制结果转化为十进制

		00000011
		00000101
		00000110-->6

		~6 = ?
		知识补充
		原码   反码  补码  二进制表示数字

		           6					-6
原码：00000000 00000000 00000000 00000110	10000000 00000000 00000000 00000110
反码：00000000 00000000 00000000 00000110	11111111 11111111 11111111 11111001  符号不动 其余取反
补码：00000000 00000000 00000000 00000110   11111111 11111111 11111111 11111010  反码+1
计算机中不管是整数还是负数 存储的形式都是以补码形式来存储
注意 反码是一种表示形式  取反是一个计算过程(每一个位置都取反)

		6<<2 =24
		00000000 00000000 00000000 00000110
                                  000000 00000000 00000000 0000011000
		相当于乘以2的位移次幂
		
		6>>1==3
		00000000 00000000 00000000 00000110
		0000000000 00000000 00000000 000001
		相当于除以2的位移次幂

		-6>>>1
		11111111 11111111 11111111 11111010
		?11111111 11111111 11111111 1111101
		>>保留符号位置 1  填1
		>>> 不保留符号 不管是什么 都填0



