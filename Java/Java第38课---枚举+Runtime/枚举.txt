知识回顾
	1.策略模式Strategy-----行为型模式的一种
	用于解决执行流程固定，执行结果不相同，由于提供了不同的执行策略--结果就不同
	银行类			用来定义流程
	   办理业务方法(人){		用来提供策略(抽象类 接口)
		流程固定		传递的参数是抽象类或接口
		叫一个号码	真实执行传递的是子类的对象---多态
		办理业务		执行结果是子类重写之后的效果
		离开
	   }
	2.Java内部类
	内部类指的是将一个类的定义放置在另一个类的内部
		类的内部 与成员并列
		类成员的内部 与临时变量并列
	省略一个类文件.java   在内部类中可以访问外部类的成员
	LinkedBox
		Node
	成员内部类
		将类的定义直接放在另一个类中，与成员并列
		可以用任何的修饰符来修饰
		内部类可以直接使用外部类的成员
		若内部类与外部类成员重名，通过外部类.this.name
		如果想要使用内部类的属性和方法 必须创建对象   通过外部类对象操作
		注意内部类命名 : 外部类$内部类.class
	局部内部类
		将类定义放在类成员中，与局部变量并列
		局部内部类只能用abstract和final来修饰
		在不同的方法中定义重名的局部内部类
		注意局部内部类命名 : 外部类$1内部类.class
		局部内部类可以访问外部类成员  局部内部类也能访问局部变量 要求局部的变量必须final修饰
	匿名内部类
		将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类
		匿名内部类没有类的所有结构(名字 修饰符) 只有类体
		通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类
		匿名类内部没有构造方法，也不能用任何修饰符来修饰
	静态内部类
		只能在类中定义，作为成员
		静态内部类不需要外部类对象操作，可以直接创建对象
		静态内部类可以访问外部类的静态成员
=======================================================================
	数据类型
	基本	8个
	引用	数组[]  类class 抽象类abstract class 接口interface 枚举enum 注解@interface
	
	枚举类
	一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来
	1.试一试若没有枚举类型的时候  如何手动设计  (静态常量 单例模式)  Day(类 当做描述星期 7个对象)
		private构造方法
		public static final属性 = new
	2.JDK1.5版本之后可以直接定义enum类型
		我们自己定义的enum类型直接默认继承Enum(java.lang包)
		我们自己定义的enum类型不能再写extends 但是可以实现
		Enum类型
			有两个属性
			name----->枚举对象的名字     name()获取name属性
			ordinal--->枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号
			一些常用的方法
			valueOf()   通过给定的name获取对应的枚举对象
			values()     获取全部的枚举对象  ---> 返回一个数组  Day[]
			compareTo()   可以比较两个枚举对象   int
			toString()	  由于这个方法没有final修饰  可以覆盖(重写)
	3.switch内部判断枚举的应用
		
	4.我们也可以在enum中描述自己的一些属性或方法
		必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;
		可以定义自己的属性
		类创建的过程中  帮我们创建枚举类型的对象
		需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载

======================================================================
	所有面向对象的变成思想都讲完啦
	如何描述类
		类成员四个  方法
	如何创建对象
		执行类成员
	类之间的关系
		is-a  has-a  use-a
	类中特性
		权限   特征
	类之间的设计问题
		设计模式   单例  策略  适配器
	类中的一些细节
		内部类  枚举类
	内存机制问题
		类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行
		栈内存--->Person p = new Person();---->堆内存    方法区---类模板
		栈内存--->创建开始 用完立即回收   StackOverflowError
		方法区--->类   常量   静态   只有一份回收不了
		堆内存--->new创建的对象  Garbage Collection垃圾回收器  GC
	Runtime类之中提供了几个管理内存的方法
		maxMemory
		totalMemory
		freeMemory
		堆内存溢出错误OutOfMemoryError
	Object类中有一个finalize方法  如果重写也能看见对象回收
	GC系统提供的一个线程    回收算法
==================================================================
	人家写好的类
	包装类
	数学相关
	日期相关
	字符串
	集合
	输入输出I/O
	异常相关
	线程相关
	网络相关















