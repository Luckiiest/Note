知识回顾
1.常量
	常量是一个值
	在程序运行的过程中不能再次发生改变
	基本类型的值都可以认为是常量   4  3.4  'a'  true
	String类   引用数据类型   值"abc"  视为常量
	常量存储在常量缓冲区(常量池)中，有且只有一份
	常量池中的值默认空间大小  32bit--int   64bit--double
2.变量
	变量是一个内存空间(小容器)
	在栈内存中开辟的一块内存空间
	空间在开辟(变量声明) 必须指定类型 名字(规则规约)
	变量空间内容有且只有一个(只能存一份 值 引用)
	空间内的内容的类型与定义时一致 内容可以改变 
	声明变量时需要注意的问题
		float x = 3.4F；
		long y = 2147489999L;//如果超过int的取值范围2147483647
3.内存结构与执行过程
	类的定义 编译 加载 空间各个区 变量 赋值
====================================================
数据类型之间的转化问题
	int a = 1;
	int b = a;
	-----------
	-----------
		整型
		   byte short int long
		浮点
		   float double
		字符
		   char
		布尔
		   boolean
	byte a = 1;//8bit    -128~127
	int b = a;  //32bit
		食堂吃饭
		一碗米饭    2两碗    1两米饭/1两空气
		                 4两碗  
	int a = 1000;//编译--运行
	byte b = (byte)a;//127  强制类型转换
		a--->   4两碗     3两米饭/1两空气   空气强制砍掉一部分
		b--->   2两碗     1两米饭/1两空气   -24
	00000000 00000000 00000000 00000001---只保留最后的8bit位
	00000000 00000000 00000011 11101000---十进制-->二进制  除以2取余数 余数倒序排列

	int a = 1;// 32bit
	float b = a;// 32bit ????可以   b==1.0   精确程度

	long a = 1;//64bit
	float b = a;//32bit
	

	char---字符---'a'---0001010101---97---int
	char x = 'a';
	int y = x;//???  y-->97


	类型之间的转换问题
	1.同种数据类型之间是可以直接进行赋值操作
		int a = 1;int b = a;||    float x = 3.4;float y = x;
	2.数据类型不同的空间 之间的赋值--->转换问题
		同种大数据类型之间才能发生转换
		   基本类型----基本类型之间   可以直接转换(自动 强制)
		   引用类型----引用类型之间   可以直接转换(自动 强制--上转型 下转型)
		   基本类型----引用类型之间   不可以直接转换(间接--包装类/封装类)
			
	3.保证大数据类型一致的前提下
		基本类型---基本类型
		   小数据类型相同
		      都是整型  都是浮点
			大空间变量可以直接存储小空间的数据
			小空间变量不可以直接存储大空间的数据(需要强制类型转换)
			转换过程写法都好用  如果转换的过程中数值范围超过边界  可能会有损失
			byte a = 1;   int b = a;//自动直接转化就可以
			int a = 1;  byte b = (byte)a;//需要强制类型转换
			float x = 3.4F;   double y = x;//自动直接转化
			double x = 3.4; float y = (float)x;//强制转换
			如果发现强制转换之前的数值比较大 强制转化这件事情可以
			int a = 1000; byte b = (byte)a;//编译好用 执行后 b存放的值一定发生变化
		   小数据类型不同
		      整型---浮点型
			两个比较精确程度  浮点型精确程度更高 可以直接存放整数 反之需要强制转换
			任何一个浮点型都可以直接存放一个整型
			int a = 1;  float b = a;//自动直接转化
			float a =1.0F;  int b = (int)a;//强制类型转换
		     整型---字符型
			每一个字符都对应这一个Unicode码   a--97
			char x = 'a';  int y = x;//自动转化  y--97
			int x = 97; char y = (char)x;//强制的转化
		     布尔类型很特殊
			不能与其他基本类型之间发生转化
		引用类型之间后续...
		




