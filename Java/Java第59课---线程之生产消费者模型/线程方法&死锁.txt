知识回顾
	1.三个非常重要的概念
	  程序---->   一组写好了的静态的代码
	  进程---->   正在进行着的程序   静态的代码执行起来啦
	  线程---->   是进程内的小单元   很多线程同时执行
	2.需要掌握线程的几种不同的状态  及如何切换
	   new对象           start()       CPU分配run()    wait()        exception 
	  创建线程(对象)----就绪状态----执行状态----等待/挂起----异常/消亡
			   |                                    |
			   |__________________________|
			          notify/notifyAll
	3.如何实现线程
	   自定义一个类
	   继承Thread    实现Runnable
	   重写run方法
	   调用start方法  让线程进入就绪状态  需要注意的是start方法Thread类中

	购票的小例子
	利用Vector集合   线程安全   多个线程并发操作同一个集合的时候  不会抢夺资源
	   
	生产消费者模型
	1.通过这个模型  成功的演示出了  线程安全的问题
		两个消费者  同时访问同一个仓库对象   仓库内只有一个元素的时候
		两个消费者并发访问  会有可能产生抢夺资源的问题
	2.自己解决一下线程安全的问题
		让仓库对象被线程访问的时候   仓库对象被锁定
		仓库对象只能被一个线程访问   其他的线程处于等待状态
		特征修饰符
		synchronized  同步  一个时间点只有一个线程访问
		线程安全锁
		两种形式写法
		1.将synchronized关键字 放在方法的结构上
		   public synchronized void get(){}
		   锁定的是调用方法时的那个对象
		2.将synchronized关键字 方在方法(构造方法 块)的内部  
		   public void get(){
			好多代码
			synchronized(对象){
				好多代码
			}
			好多代码
		   }
	3.我们觉得return不是很好
		应该让线程的不同状态来回切换
		执行   等待   执行   等待
		wait()	Object类中的方法
		对象.wait();
		对象.wait(); 不是当前的这个对象wait
			  访问当前这个对象的线程wait
		notify
		notifyAll
		p.setPriority(10);		p.getPriority();

		产生一个类似假死状态
		所有的线程都进入等待状态  没有线程做事

	4.通过上述的生产消费者模型
		做一个非常完整而且安全的模型
		1.利用线程安全锁    特征修饰符synchronized 
			两种不同的写法
			不管怎么写   锁定的永远是对象
		2.利用方法控制线程状态的来回切换
			wait
			notify	notifyAll
			上述三个方法都是Object类中的方法
		3.Thread类中的方法
			sleep方法    静态方法(参数long 毫秒值)
			setPriority(10);	getPriority();
			设置/获取线程的优先级  1-10  
			数字越高优先级越高   更加容易获取CPU分配的资源碎片
		4.笔试题
			程序 进程 线程 概念的区别
			线程的创建方式
			线程的几种状态  如何切换
				sleep方法   wait方法的区别
			1.类	Thread类	  Object类
			2.调用	静态 类名.   对象.
			3.理解	哪个位置调用   对象调用方法
				哪个线程等待   访问对象的其他线程等待
			4.唤醒	不需要别人      需要其他对象调用notify唤醒
			5.锁	不会释放锁      等待后会释放锁
			
	5.join方法	Thread类中的方法
		让多个线程同步执行  变成单个线程
	6.死锁





